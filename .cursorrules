# Cursor Rules - Prospect Forge Flow

## üéØ CONTEXTE DU PROJET

Ce projet est une application de gestion de prospects CRM construite avec React, TypeScript, Vite et Supabase. L'application g√®re les contacts provenant de diff√©rentes sources (Apollo, HubSpot, CRM) et permet aux √©quipes commerciales de traiter et suivre les prospects.

## üèóÔ∏è ARCHITECTURE ET STRUCTURE

### Structure des dossiers
```
src/
‚îú‚îÄ‚îÄ components/          # Composants React r√©utilisables
‚îÇ   ‚îú‚îÄ‚îÄ ui/             # Composants UI de base (shadcn/ui)
‚îÇ   ‚îî‚îÄ‚îÄ [feature]/      # Composants sp√©cifiques aux fonctionnalit√©s
‚îú‚îÄ‚îÄ pages/              # Pages principales de l'application
‚îú‚îÄ‚îÄ hooks/              # Hooks personnalis√©s React
‚îú‚îÄ‚îÄ integrations/       # Int√©grations externes (Supabase)
‚îú‚îÄ‚îÄ lib/                # Utilitaires et helpers
‚îî‚îÄ‚îÄ main.tsx           # Point d'entr√©e de l'application
```

### Technologies utilis√©es
- **Frontend**: React 18, TypeScript, Vite
- **UI**: shadcn/ui, Tailwind CSS, Radix UI
- **Backend**: Supabase (PostgreSQL, Auth, Edge Functions)
- **State Management**: React Query, React Context
- **Forms**: React Hook Form + Zod validation
- **Routing**: React Router v6
- **Icons**: Lucide React

## üìã R√àGLES DE D√âVELOPPEMENT

### 1. LANGUE ET COMMUNICATION
- **TOUJOURS r√©pondre en fran√ßais** dans les commentaires et messages
- **JAMAIS d'emojis dans le code** - utiliser uniquement du texte
- Les messages d'erreur et de succ√®s doivent √™tre en fran√ßais
- Les noms de variables et fonctions peuvent √™tre en anglais

### 2. ARCHITECTURE CLEAN CODE

#### S√©paration des responsabilit√©s
- **Pages** : Logique de routage et orchestration des composants
- **Composants** : Logique d'affichage et interactions utilisateur
- **Hooks** : Logique m√©tier et gestion d'√©tat
- **Services** : Appels API et int√©grations externes

#### Structure des composants
```typescript
// 1. Imports externes
import React from 'react';
import { useForm } from 'react-hook-form';

// 2. Imports internes (composants UI)
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';

// 3. Imports de hooks et services
import { useAuth } from '@/hooks/useAuth';
import { supabase } from '@/integrations/supabase/client';

// 4. Types et interfaces
interface ComponentProps {
  // Props definition
}

// 5. Constantes
const CONSTANTS = {
  // Constants definition
};

// 6. Composant principal
export const Component: React.FC<ComponentProps> = ({ prop1, prop2 }) => {
  // Hooks
  // State
  // Effects
  // Handlers
  // Render
};
```

### 3. GESTION D'√âTAT ET DONN√âES

#### Hooks personnalis√©s
- Cr√©er des hooks pour la logique m√©tier complexe
- Utiliser React Query pour la gestion des donn√©es serveur
- S√©parer la logique de r√©cup√©ration des donn√©es de l'affichage

#### Exemple de hook personnalis√©
```typescript
export const useTableData = (params: UseTableDataParams) => {
  const [data, setData] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  
  const fetchData = async () => {
    setLoading(true);
    try {
      const { data: response, error } = await supabase.functions.invoke('table-data', {
        body: params
      });
      
      if (error) throw error;
      setData(response?.data || []);
    } catch (error) {
      console.error('Error fetching data:', error);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchData();
  }, [/* dependencies */]);
  
  return { data, loading, refetch: fetchData };
};
```

### 4. FORMULAIRES ET VALIDATION

#### Utilisation de React Hook Form + Zod
```typescript
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const formSchema = z.object({
  email: z.string().email('Email invalide'),
  name: z.string().min(1, 'Le nom est requis'),
});

type FormData = z.infer<typeof formSchema>;

const Component = () => {
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      email: '',
      name: '',
    },
  });
  
  const onSubmit = (data: FormData) => {
    // Handle form submission
  };
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)}>
        {/* Form fields */}
      </form>
    </Form>
  );
};
```

### 5. GESTION DES ERREURS

#### Messages d'erreur en fran√ßais
```typescript
const handleError = (error: any) => {
  toast({
    variant: "destructive",
    title: "Erreur",
    description: "Une erreur est survenue lors de l'op√©ration.",
    duration: 4000
  });
};
```

#### Gestion des √©tats de chargement
```typescript
const [loading, setLoading] = useState(false);

const handleAction = async () => {
  setLoading(true);
  try {
    // Action
  } catch (error) {
    handleError(error);
  } finally {
    setLoading(false);
  }
};
```

### 6. TYPES ET INTERFACES

#### Naming conventions
- Interfaces : `PascalCase` (ex: `UserProfile`, `TableData`)
- Types : `PascalCase` (ex: `FormData`, `ApiResponse`)
- Enums : `PascalCase` (ex: `UserRole`, `ProspectStatus`)

#### Exemple de types
```typescript
interface ProspectData {
  id: string;
  email: string;
  name: string;
  status: ProspectStatus;
  createdAt: string;
  updatedAt: string;
}

type ProspectStatus = 'RDV' | 'B' | 'R√âPONDEUR' | 'MAIL √Ä ENVOYER' | 'MAIL ENVOY√â';

interface UseTableDataParams {
  tableName: string;
  page: number;
  pageSize: number;
  searchTerm?: string;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}
```

### 7. INT√âGRATION SUPABASE

#### Configuration client
```typescript
import { supabase } from '@/integrations/supabase/client';

// Utilisation des Edge Functions
const { data, error } = await supabase.functions.invoke('function-name', {
  body: { /* params */ }
});

// Requ√™tes directes
const { data, error } = await supabase
  .from('table_name')
  .select('*')
  .eq('column', value);
```

### 8. ROUTING ET NAVIGATION

#### Structure des routes
- Utiliser React Router v6
- Routes prot√©g√©es avec `ProtectedRoute`
- Layout commun avec `Layout` component
- Navigation programmatique avec `useNavigate`

#### Exemple de route
```typescript
<Route 
  path="/prospects" 
  element={
    <ProtectedRoute>
      <Layout>
        <Prospects />
      </Layout>
    </ProtectedRoute>
  } 
/>
```

### 9. STYLING ET UI

#### Tailwind CSS
- Utiliser les classes Tailwind pour le styling
- √âviter les styles inline
- Utiliser les composants shadcn/ui comme base

#### Composants UI
```typescript
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
```

### 10. PERFORMANCE ET OPTIMISATION

#### React Query
- Utiliser React Query pour le cache des donn√©es
- Impl√©menter la pagination c√¥t√© serveur
- Utiliser `useMemo` et `useCallback` pour les calculs co√ªteux

#### Lazy loading
```typescript
const LazyComponent = React.lazy(() => import('./LazyComponent'));

// Dans le composant
<Suspense fallback={<div>Chargement...</div>}>
  <LazyComponent />
</Suspense>
```

## üö´ INTERDICTIONS

### Code
- **JAMAIS d'emojis** dans le code source
- **JAMAIS de console.log** en production
- **JAMAIS de any** sans justification
- **JAMAIS de mutations directes** d'√©tat
- **JAMAIS de props drilling** excessif

### Architecture
- **JAMAIS de logique m√©tier** dans les composants UI
- **JAMAIS d'appels API** directement dans les composants
- **JAMAIS de gestion d'√©tat globale** sans justification
- **JAMAIS de d√©pendances circulaires**

## ‚úÖ BONNES PRATIQUES

### Code Quality
- Utiliser TypeScript strict
- Impl√©menter la validation avec Zod
- G√©rer les √©tats de chargement et d'erreur
- Utiliser des noms de variables explicites
- Commenter le code complexe en fran√ßais

### Performance
- Impl√©menter la pagination
- Utiliser React.memo pour les composants lourds
- Optimiser les re-renders avec useMemo/useCallback
- Lazy loading des composants volumineux

### S√©curit√©
- Valider toutes les entr√©es utilisateur
- Utiliser les RLS (Row Level Security) de Supabase
- Impl√©menter l'authentification et l'autorisation
- Sanitizer les donn√©es avant affichage

## üîß OUTILS ET COMMANDES

### D√©veloppement
```bash
npm run dev          # Serveur de d√©veloppement
npm run build        # Build de production
npm run lint         # V√©rification ESLint
npm run preview      # Pr√©visualisation du build
```

### Installation
```bash
npm install --legacy-peer-deps  # Installation avec r√©solution de conflits
```

## üìù EXEMPLES DE CODE

### Composant avec formulaire
```typescript
import React, { useState } from 'react';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Button } from '@/components/ui/button';
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { useToast } from '@/hooks/use-toast';

const formSchema = z.object({
  name: z.string().min(1, 'Le nom est requis'),
  email: z.string().email('Email invalide'),
});

type FormData = z.infer<typeof formSchema>;

interface ComponentProps {
  onSubmit: (data: FormData) => Promise<void>;
}

export const Component: React.FC<ComponentProps> = ({ onSubmit }) => {
  const [loading, setLoading] = useState(false);
  const { toast } = useToast();
  
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      name: '',
      email: '',
    },
  });
  
  const handleSubmit = async (data: FormData) => {
    setLoading(true);
    try {
      await onSubmit(data);
      toast({
        title: "Succ√®s",
        description: "L'op√©ration a √©t√© effectu√©e avec succ√®s.",
      });
    } catch (error) {
      toast({
        variant: "destructive",
        title: "Erreur",
        description: "Une erreur est survenue lors de l'op√©ration.",
      });
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(handleSubmit)} className="space-y-4">
        <FormField
          control={form.control}
          name="name"
          render={({ field }) => (
            <FormItem>
              <FormLabel>Nom</FormLabel>
              <FormControl>
                <Input {...field} />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />
        <Button type="submit" disabled={loading}>
          {loading ? "En cours..." : "Valider"}
        </Button>
      </form>
    </Form>
  );
};
```

### Hook personnalis√©
```typescript
import { useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';

interface UseDataParams {
  tableName: string;
  page: number;
  pageSize: number;
}

interface UseDataReturn {
  data: any[];
  loading: boolean;
  error: string | null;
  refetch: () => void;
}

export const useData = ({ tableName, page, pageSize }: UseDataParams): UseDataReturn => {
  const [data, setData] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  
  const fetchData = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const { data: response, error: fetchError } = await supabase.functions.invoke('table-data', {
        body: { tableName, page, pageSize }
      });
      
      if (fetchError) throw fetchError;
      
      setData(response?.data || []);
    } catch (err) {
      setError('Erreur lors du chargement des donn√©es');
      console.error('Error fetching data:', err);
    } finally {
      setLoading(false);
    }
  };
  
  useEffect(() => {
    fetchData();
  }, [tableName, page, pageSize]);
  
  return { data, loading, error, refetch: fetchData };
};
```

## üéØ OBJECTIFS DE QUALIT√â

1. **Maintenabilit√©** : Code lisible et bien structur√©
2. **Performance** : Optimisation des re-renders et chargements
3. **S√©curit√©** : Validation et sanitisation des donn√©es
4. **Exp√©rience utilisateur** : Interface intuitive et responsive
5. **√âvolutivit√©** : Architecture modulaire et extensible

Respecter ces r√®gles garantit un code de qualit√©, maintenable et performant pour l'application Prospect Forge Flow.
